created: 20210104125319429
creator: Syan
modified: 20210118124631038
modifier: Syan
tags: 计算机网络
title: 传输层
tmap.id: fb8554fc-25b9-4c23-a997-825cc9f5bd83
type: text/vnd.tiddlywiki

传输层的功能：

* 传输层提供进程和进程之间的逻辑通信
* 复用与分用
* 对收到报文进行差错检测

TCP：面向连接的传输控制协议TCP

* 在传送数据之前建立连接，结束释放连接。
* 不提供广播和多播服务
* 增加确认、流量控制、计时器及连接管理开销
* 可靠、面向连接，时延大，适用于大文件

UDP：无连接的用户数据报协议UDP

* 传输不建立连接
* 传输不需要确认
* 不可靠、无连接、时延小、适用于小文件

传输层的寻址与端口

* 复用：应用层的所有进程都可以通过传输层传到网络层
* 分用：传输层从网络层收到数据后交付指明应用进程
* 逻辑端口是传输层的SAP，标识主机中的应用进程

端口号只有本地意义，因特网中不同计算机相同端口无联系

端口号长度为16bit，总共有65536个不同端口

*端口号（按范围划分）
** 服务端使用的端口号
*** 熟知端口号（0~1023）：给TCP/IP重要应用程序，公认端口
*** 登记端口号（1024~49151）：为没有熟知端口号的应用程序使用
** 客户端使用的端口号（49152~65536）：在客户进程运行时动态选择

使用套接字描述网络中的一个主机和它上面的一个进程

[img[https://img-blog.csdnimg.cn/20200630095258962.png]]















! UDP协议

UDP只在IP数据报服务上增加了很少功能，即复用分用和差错检测功能

!! UDP的主要特点

* UDP是无连接的，减少开销和发送数据之前的时延
* UDP使用最大努力交付，即不保证可靠交付
* UDP是面向报文的，适合一次性传输少量数据的网络应用（不进行切片）
* UDP无拥塞控制，适合很多实时应用
* UDP首部开销小，为8字节（对比TCP20字节）

!! UDP数据报格式

| 16位源端口号 2B | 16位目的端口号 2B |
| 16位UDP长度 2B | 16位UDP校验和 2B |
| 数据 |<|

!!UDP校验计算

*发送端
*#将每一行（4字节）拆成两部分，左右平均2字节大小，将这两字节数据写成二进制，那么2字节一共就需要2*8=16位。此时检验和没有计算，默认填充0，同时如果数据字段不整齐，则用0补齐，这样就可以写出几十行二进制数，如图中所示
*#计算着几十行二进制数按二进制反码运算求和，得到的最后简介再反码，之后将反码之后的放入原来的检验和字段
* 接收端
*# 按照发送端的步骤再将所有数据写成二进制进行二进制反码运算求和
*# 如果最后得到结果全1就是没问题，否则丢弃

[img[https://img-blog.csdnimg.cn/20200630105526400.png]]


















! TCP协议

!! TCP的主要特点

* TCP是面向连接（虚连接）的传输层协议
* 每一条TCP连接只有两个端点，只能点对点
* TCP提供可靠的交付服务，无差错、不丢失、无重复、按序到达。可靠有序、不丢不重
* TCP提供全双工通信
** 发送缓存：准备发送的数据&已发送但是尚未收到确认的数据
** 按序到达但尚未被接受应用程序读取的数据&不按序到达的数据
* TCP面向字节流：TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流
** 将数据流切分编号发送

!! TCP报文段首部格式

[img[http://kodo.cyasylum.top/2021/01/05/17bae2edf0a30.png]]























* 序号：在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号
* 确认号：期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N,则证明到序号N-1为止的所有数据都己正确收到。
* 数据偏移（首部长度）：TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。
* 控制位：
** 紧急位URG：URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合紧急指针字段使用。
** 确认位ACK：ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1.
** 推送位PSH：PSH=1时，接收方尽快交付接收应用进程，不再等到缓存填满再向上交付。
** 复位RST：RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立传输链接。
** 同步位SYN：SYN=1时，表明是一个连接请求/连接接受报文。
** 终止位FIN：FIN=1时，表明此报文段发送方数据已发完，要求释放连接。
* 窗口：指发送报文段一方的接受窗口，控制发送方发送缓存大小。
* 校验和：检验首部加数据校验，加入伪首部，第四字段为6
* 紧急指针：URG=1时有意义
* 选项：最大报文段长度、窗口扩大、时间戳、选择确认···






!! TCP连接管理

* 连接建立
* 数据传送
* 连接释放

客户&服务器方式。主动发起连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫服务器。

!!! TCP的连接建立

三次握手

* 客户端发送连接请求报文段，无应用层数据
** SYN=1，seq=x(rand)
* 服务器反馈确认报文段允许连接，为TCP连接分配缓存和变量，无应用层数据
** SYN=1，ACK=1，seq=y(rand)，ack=x+1
* 客户端返回确认的确认，分配缓存和变量，可以携带数据。
** SYN=0，ACK=1，seq=x+1，ack=y+1

<<<
SYN洪范攻击：

发生在OSl第四层，这种方式利用TCP协议的特性，就是三次握手。攻击者发送TCP SYN,SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TcP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。
<<<

!!! TCP的连接释放

四次握手

* 客户端发送连接释放报文段，停止发送数据，主动关闭TCP连接
** FIN=1，seq=u
* 服务端返回确认报文段，客户到服务器方向连接释放完成
** ACK=1，seq=v，ack=u+1
* 服务器发完数据，发送连接释放报文段，主动关闭TCP连接
** FIN=1，ACK=1，seq=w，ack=u+1
* 客户端回送一个确认报文段，再等到计时器设置2MSL(最长报文段寿命)后彻底关闭连接
** ACK=1，seq=u+1，ack=w+1
** 确定服务器已收到确认报文段，没有再次请求

!! TCP可靠传输

保证接收方进程从缓存区读取的字节流与发送方发出的字节流完全一样

* 校验
** 添加伪首部校验
* 序号
** 保证顺序提交发送
* 确认重传
** 未确认自动重传
** 使用动态自适应算法改变重传时间RTTs(加权平均往返时间)
** 冗余确认，在收到比期望序号大的失序报文段到达时，发送冗余ACK标识下一个期待字节流的序号，发送方收到三个冗余ACK则确认报文段丢失，进行重传

!! TCP流量控制

TCP使用滑动窗口机制实现流量控制

通信过程中，接收方根据自己接收缓存的大小，动态调整发送方的发送窗口大小，即告知接收窗口rwnd（设置确认报文段中的窗口字段通知）。发送方发送窗口取接收窗口rwnd和拥塞窗口cwnd的最小值。

接收方可以发送0窗口rwnd让发送方暂停发送数据，发送方收到设置计时器，若设置时间到期则发送零窗口探测报文段，接收方收到探测则返回当前接收窗口值

!! TCP拥塞控制

出现拥塞条件：对资源需求的总和>可用资源

网络中资源同时呈现供应不足——》网络性能变坏——》网络吞吐量随输入负荷增大而下降

拥塞控制防止过多的数据注入网络中，具有全局性。

* 慢开始&拥塞避免
* 快重传&快恢复

假设：

# 数据单方向发送，另一方向只传送确认
# 接收方总是有足够大的缓存空间，因而发送窗口带线啊哦取决于拥塞程度
#*发送窗口=Min{接收窗口rwnd，拥塞窗口cwnd}
#* 接收窗口：接收方根据接受缓存设置的值，告知发送方反映接收方容量
#* 拥塞窗口：发送方根据自己估算的网络拥塞程度设置的窗口值，反映网络当前容量

!!! 慢开始&拥塞避免

[img[http://kodo.cyasylum.top/2021/01/18/b91cabf6a9999.png]]














!!! 快重传&快恢复

[img[http://kodo.cyasylum.top/2021/01/18/951d81ed1a66f.png]]












